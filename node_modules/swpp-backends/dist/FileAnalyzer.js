"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceRequest = exports.findCache = exports.eachAllLinkInUrl = exports.findFileHandler = exports.registryFileHandler = exports.submitExternalUrl = exports.submitCacheInfo = exports.loadVersionJson = exports.isStable = exports.isExclude = exports.buildVersionJson = void 0;
const buffer_1 = require("buffer");
const crypto = __importStar(require("crypto"));
const fast_html_parser_1 = __importDefault(require("fast-html-parser"));
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = require("node-fetch");
const path_1 = __importDefault(require("path"));
const SwppConfig_1 = require("./SwppConfig");
const Utils_1 = require("./Utils");
const Variant_1 = require("./Variant");
/**
 * 构建一个 version json
 *
 * + **执行该函数前必须调用过 [loadRules]**
 * + **调用该函数前必须调用过 [loadCacheJson]**
 * + **执行该函数前必须调用过 [calcEjectValues]**
 *
 * @param protocol 网站的网络协议
 * @param domain 网站域名（包括二级域名）
 * @param root 网页根目录（首页 index.html 所在目录）
 */
async function buildVersionJson(protocol, domain, root) {
    const key = 'newVersionJson';
    if ((0, Variant_1.readVariant)(key)) {
        (0, Utils_1.error)('VersionJsonBuilder', '已经构建过一次版本文件');
        throw '重复构建版本文件';
    }
    const rules = (0, Variant_1.readRules)();
    const config = rules.config;
    const list = {};
    const cacheInfoMap = (0, Variant_1.readEvent)('submitCacheInfo');
    const urlList = (0, Variant_1.readEvent)('submitExternalUrl');
    (0, Variant_1.writeVariant)('submitCacheInfo', false);
    (0, Variant_1.writeVariant)('submitExternalUrl', false);
    // 遍历所有文件
    await eachAllFile(root, async (path) => {
        const endIndex = path.length - (/[\/\\]index\.html$/.test(path) ? 10 : 0);
        const url = new URL(protocol + path_1.default.join(domain, path.substring(root.length, endIndex)));
        const pathname = url.pathname;
        if (isExclude(domain, pathname))
            return;
        let content = null;
        if (findCache(url)) {
            // 对于需要缓存的文件计算 MD5 值并存储
            content = fs_1.default.readFileSync(path, 'utf-8');
            const key = decodeURIComponent(url.pathname);
            list[key] = crypto.createHash('md5').update(content).digest('hex');
        }
        if (!config.external)
            return;
        // 分析外部文件
        const handler = findFileHandler(pathname);
        if (handler) {
            if (!content)
                content = fs_1.default.readFileSync(path, 'utf-8');
            await handler.handle(domain, url.href, content, list);
        }
    });
    if (config.external) {
        // 分析规则文件中通过 extraListenedUrls 导入的 URL
        if ('extraListenedUrls' in rules) {
            const urls = rules.extraListenedUrls;
            if (typeof urls.forEach !== 'function') {
                (0, Utils_1.error)('VersionJsonBuilder', `规则文件中的 extraListenedUrls 缺少 forEach 函数`);
                throw 'extraListenedUrls 类型错误';
            }
            urls.forEach((it) => {
                if (typeof it !== 'string') {
                    (0, Utils_1.error)('VersionJsonBuilder', 'extraListenedUrls 中应当存储 string 类型的值');
                    throw 'extraListenedUrls 元素类型错误';
                }
                urlList.add(it);
            });
        }
        // 处理通过 API 提交的 URL
        for (let url of urlList) {
            await eachAllLinkInUrl(domain, url, list);
        }
    }
    const external = {};
    cacheInfoMap.forEach((value, key) => {
        external[key] = value;
    });
    if ('update' in rules) {
        external.swppFlag = rules.update.flag;
    }
    return (0, Variant_1.writeVariant)('newVersionJson', (0, Utils_1.deepFreeze)({
        version: 3,
        list, external
    }));
}
exports.buildVersionJson = buildVersionJson;
/**
 * 遍历指定目录及其子目录中包含的所有文件（不遍历文件夹）
 * @param root 根目录
 * @param cb 回调函数（接收的参数是文件的相对路径）
 */
async function eachAllFile(root, cb) {
    const stats = fs_1.default.statSync(root);
    if (stats.isFile())
        await cb(root);
    else {
        const files = fs_1.default.readdirSync(root);
        await Promise.all(files.map(it => eachAllFile(path_1.default.join(root, it), cb)));
    }
}
/**
 * 判断指定 URL 是否排除
 *
 * + **执行该函数前必须调用过 [loadRules]**
 *
 * @param domain 网站域名
 * @param url 要判断的 URL
 */
function isExclude(domain, url) {
    const exclude = (0, Variant_1.readRules)().config?.json?.exclude;
    if (!exclude)
        return false;
    const list = isExternalLink(domain, url) ? exclude.other : exclude.localhost;
    for (let reg of list) {
        if (url.match(reg))
            return true;
    }
    return false;
}
exports.isExclude = isExclude;
/**
 * 判断指定 URL 是否是 stable 的
 *
 * + **执行该函数前必须调用过 [loadRules]**
 */
function isStable(url) {
    const stable = (0, Variant_1.readRules)().config?.external?.stable;
    if (!stable)
        return false;
    for (let reg of stable) {
        if (url.match(reg))
            return true;
    }
    return false;
}
exports.isStable = isStable;
/**
 * 从指定 URL 加载 version json
 *
 * + **执行该函数前必须调用过 [loadRules]**
 */
async function loadVersionJson(url, level = SwppConfig_1.FileFetchModeLevel.NORMAL) {
    const key = 'oldVersionJson';
    const response = await (0, Utils_1.fetchFile)(url).catch(err => err);
    switch (true) {
        case response.status == 404 && level >= SwppConfig_1.FileFetchModeLevel.NORMAL:
        case response.code == 'ENOTFOUND' && level == SwppConfig_1.FileFetchModeLevel.LOOSE:
            (0, Utils_1.warn)('VersionJsonLoader', `拉取 ${url} 时出现 404 错误，如果您是第一次构建请忽略这个警告。`);
            return (0, Variant_1.writeVariant)(key, null);
        default:
            (0, Utils_1.error)('VersionJsonLoader', `拉取 ${url} 时出现 ${response.status} 错误！`);
            if ('status' in response)
                throw `拉取时出现 ${response.status} 异常`;
            throw response;
        case [200, 301, 302, 307, 308].includes(response.status):
            return (0, Variant_1.writeVariant)(key, await response.json());
    }
}
exports.loadVersionJson = loadVersionJson;
/** 提交要存储到 version json 的值 */
function submitCacheInfo(key, value) {
    const cacheInfoMap = (0, Variant_1.readEvent)('submitCacheInfo');
    cacheInfoMap.set(key, value);
}
exports.submitCacheInfo = submitCacheInfo;
/** 添加一个要监听的 URL */
function submitExternalUrl(url) {
    (0, Variant_1.readEvent)('submitExternalUrl').add(url);
}
exports.submitExternalUrl = submitExternalUrl;
(0, Variant_1.writeVariant)('submitCacheInfo', new Map());
(0, Variant_1.writeVariant)('submitExternalUrl', new Set());
(0, Variant_1.writeVariant)('registryFileHandler', []);
(0, Variant_1.readVariant)('registryFileHandler').push(...[
    {
        match: (url) => /(\/|\.html)$/.test(url),
        handle: eachAllLinkInHtml
    },
    {
        match: (url) => url.endsWith('.css'),
        handle: eachAllLinkInCss
    },
    {
        match: (url) => url.endsWith('.js'),
        handle: eachAllLinkInJavaScript
    }
]);
/** 注册一个文件处理器 */
function registryFileHandler(handler) {
    // noinspection JSMismatchedCollectionQueryUpdate
    (0, Variant_1.readEvent)('registryFileHandler').push(handler);
}
exports.registryFileHandler = registryFileHandler;
/** 查询一个文件处理器 */
function findFileHandler(url) {
    return (0, Variant_1.readEvent)('registryFileHandler').find(it => it.match(url));
}
exports.findFileHandler = findFileHandler;
/**
 * 检索一个 URL 指向的文件中所有地外部链接
 *
 * 该函数会处理该 URL 指向的文件和文件中直接或间接包含的所有 URL
 *
 * + **执行该函数前必须调用过 [loadRules]**
 * + **调用该函数前必须调用过 [loadCacheJson]**
 * + **执行该函数前必须调用过 [calcEjectValues]**
 *
 * @param domain 网站域名
 * @param url 要检索的 URL
 * @param result 存放结果的对象
 * @param event 检索到一个 URL 时触发的事件
 */
async function eachAllLinkInUrl(domain, url, result, event) {
    if (url.startsWith('//'))
        url = 'http:' + url;
    if (url in result)
        return event?.(url);
    if (!url.startsWith('http') || isExclude(domain, url))
        return;
    if (!(isExternalLink(domain, url) && findCache(new URL(url))))
        return;
    const stable = isStable(url);
    if (stable) {
        const old = (0, Variant_1.readOldVersionJson)()?.list;
        if (Array.isArray(old?.[url])) {
            const copyTree = (key) => {
                const value = old[key];
                if (!value)
                    return;
                result[key] = value;
                if (Array.isArray(value)) {
                    result[key] = value;
                    for (let url of value) {
                        copyTree(url);
                    }
                }
            };
            copyTree(url);
            event?.(url);
            return;
        }
    }
    const handler = findFileHandler(new URL(url).pathname);
    if (!handler && stable) {
        result[url] = [];
        return;
    }
    result[url] = false;
    const response = await (0, Utils_1.fetchFile)(url).catch(err => err);
    if (![200, 301, 302, 307, 308].includes(response?.status ?? 0)) {
        (0, Utils_1.error)('LinkItorInUrl', `拉取文件 [${url}] 时出现错误：${response?.status ?? response?.code}`);
        return;
    }
    event?.(url);
    if (handler) {
        const content = await response.text();
        if (stable)
            result[url] = [];
        else
            result[url] = crypto.createHash('md5').update(content).digest('hex');
        await handler.handle(domain, url, content, result, stable ? it => result[url].push(it) : undefined);
    }
    else {
        const buffer = buffer_1.Buffer.from(await response.arrayBuffer());
        result[url] = crypto.createHash('md5').update(buffer).digest('hex');
    }
}
exports.eachAllLinkInUrl = eachAllLinkInUrl;
async function eachAllLinkInHtml(domain, url, content, result, event) {
    const taskList = [];
    const each = (node) => {
        let subUrl = undefined;
        switch (node.tagName) {
            case 'link':
                // noinspection SpellCheckingInspection
                if (node.attributes.rel !== 'preconnect')
                    subUrl = node.attributes.href;
                break;
            case 'script':
            case 'img':
            case 'source':
            case 'iframe':
            case 'embed':
                subUrl = node.attributes.src;
                break;
            case 'object':
                subUrl = node.attributes.data;
                break;
        }
        if (subUrl) {
            taskList.push(eachAllLinkInUrl(domain, subUrl, result, event));
        }
        else if (node.tagName === 'script') {
            taskList.push(eachAllLinkInJavaScript(domain, url, node.rawText, result, event));
        }
        else if (node.tagName === 'style') {
            taskList.push(eachAllLinkInCss(domain, url, node.rawText, result, event));
        }
        if (node.childNodes) {
            for (let childNode of node.childNodes) {
                each(childNode);
            }
        }
    };
    let html;
    try {
        html = fast_html_parser_1.default.parse(content, { style: true, script: true });
    }
    catch (e) {
        (0, Utils_1.error)('HtmlParser', `HTML [${url}] 中存在错误语法`);
    }
    if (html)
        each(html);
    return Promise.all(taskList);
}
async function eachAllLinkInCss(domain, url, content, result, event) {
    const root = url.substring(0, url.lastIndexOf('/'));
    const urls = new Set();
    /** 从指定位置开始查询注释 */
    const findComment = (tag, start) => {
        for (let i = start; i < content.length;) {
            const item = content[i];
            switch (item) {
                case tag[0]:
                    if (content[i + 1] === tag[1])
                        return i;
                    ++i;
                    break;
                case '"':
                case '\'':
                    while (true) {
                        const index = content.indexOf(item, i + 1);
                        if (index < 0)
                            return -1;
                        i = index + 1;
                        if (content[index - 1] !== '\\')
                            break;
                    }
                    break;
                default:
                    ++i;
                    break;
            }
        }
        return -1;
    };
    for (let i = 0; i < content.length;) {
        const left = findComment('/*', i);
        let sub;
        if (left === -1) {
            sub = content.substring(i);
            i = Number.MAX_VALUE;
        }
        else {
            sub = content.substring(i, left);
            const right = findComment('*/', left + 2);
            if (right === -1)
                i = Number.MAX_VALUE;
            else
                i = right + 2;
        }
        sub.match(/(url\(.*?\))|(@import\s+['"].*?['"])|((https?:)?\/\/[^\s/$.?#].\S*)/g)
            ?.map(it => it.replace(/(^url\(\s*(['"]?))|((['"]?\s*)\)$)|(^@import\s+['"])|(['"]$)/g, ''))
            ?.map(it => {
            switch (true) {
                case it.startsWith('http'):
                    return it;
                case it.startsWith('//'):
                    return 'http' + it;
                case it.startsWith('/'):
                    return root + it;
                case it.startsWith('./'):
                    return root + it.substring(1);
                default:
                    return root + '/' + it;
            }
        })?.forEach(it => urls.add(it));
    }
    return Promise.all(Array.from(urls).map(it => eachAllLinkInUrl(domain, it, result, event)));
}
function eachAllLinkInJavaScript(domain, _, content, result, event) {
    const taskList = [];
    const ruleList = (0, Variant_1.readRules)().config?.external?.js;
    if (!ruleList) {
        (0, Utils_1.error)('LinkItorInJS', '不应发生的异常');
        throw 'ruleList 为空';
    }
    const calcRegLength = (item) => {
        let length = item.length;
        for (let i = 0; i < item.length; ++i) {
            if (item[i] === '\\') {
                ++i;
                --length;
            }
        }
        return length;
    };
    for (let value of ruleList) {
        if (typeof value === 'function') {
            const urls = value(content);
            for (let url of urls) {
                taskList.push(eachAllLinkInUrl(domain, url, result, event));
            }
        }
        else {
            const { head, tail } = value;
            const headLength = calcRegLength(head);
            const tailLength = calcRegLength(tail);
            const reg = new RegExp(`${head}(['"\`])(.*?)(['"\`])${tail}`, 'mg');
            const list = content.match(reg)
                ?.map(it => it.substring(headLength, it.length - tailLength).trim())
                ?.map(it => it.replace(/^['"`]|['"`]$/g, ''));
            if (list) {
                for (let url of list) {
                    taskList.push(eachAllLinkInUrl(domain, url, result, event));
                }
            }
        }
    }
    return Promise.all(taskList);
}
/** 判断一个 URL 是否是外部链接 */
function isExternalLink(domain, url) {
    if (url[0] === '/' && url[1] !== '/')
        return false;
    return !new RegExp(`^(https?:)?\\/\\/${domain}`).test(url);
}
/**
 * 查询指定 URL 对应的缓存规则
 *
 * + **执行该函数前必须调用过 [loadRules]**
 * + **执行该函数前必须调用过 [calcEjectValues]**
 */
function findCache(url) {
    const { cacheRules } = (0, Variant_1.readRules)();
    const eject = (0, Utils_1.readEjectData)();
    if (typeof url === 'string')
        url = new URL(url);
    url = new URL(replaceRequest(url.href));
    for (let key in cacheRules) {
        const value = cacheRules[key];
        if (value.match(url, eject?.nodeEject))
            return value;
    }
    return null;
}
exports.findCache = findCache;
/**
 * 替换请求
 *
 * + **执行该函数前必须调用过 [loadRules]**
 * + **执行该函数前必须调用过 [calcEjectValues]**
 */
function replaceRequest(url) {
    const rules = (0, Variant_1.readRules)();
    if (!('modifyRequest' in rules))
        return url;
    const { modifyRequest } = rules;
    const request = new node_fetch_1.Request(url);
    return modifyRequest?.(request, (0, Utils_1.readEjectData)()?.nodeEject)?.url ?? url;
}
exports.replaceRequest = replaceRequest;
